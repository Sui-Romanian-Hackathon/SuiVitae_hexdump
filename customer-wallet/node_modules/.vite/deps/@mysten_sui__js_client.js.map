{
  "version": 3,
  "sources": ["../../@mysten/sui.js/src/version.ts", "../../@mysten/sui.js/src/client/errors.ts", "../../@mysten/sui.js/src/client/rpc-websocket-client.ts", "../../@mysten/sui.js/src/client/http-transport.ts", "../../@mysten/sui.js/src/client/network.ts", "../../@mysten/sui.js/src/bcs/type-tag-serializer.ts", "../../@mysten/sui.js/src/bcs/index.ts", "../../@mysten/sui.js/src/transactions/Inputs.ts", "../../@mysten/sui.js/src/transactions/pure.ts", "../../@mysten/sui.js/src/transactions/utils.ts", "../../@mysten/sui.js/src/transactions/serializer.ts", "../../@mysten/sui.js/src/transactions/hash.ts", "../../@mysten/sui.js/src/transactions/Transactions.ts", "../../@mysten/sui.js/src/transactions/TransactionBlockData.ts", "../../@mysten/sui.js/src/transactions/TransactionBlock.ts", "../../@mysten/sui.js/src/client/client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '0.54.1';\nexport const TARGETED_RPC_VERSION = '1.25.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst CODE_TO_ERROR_TYPE: Record<number, string> = {\n\t'-32700': 'ParseError',\n\t'-32600': 'InvalidRequest',\n\t'-32601': 'MethodNotFound',\n\t'-32602': 'InvalidParams',\n\t'-32603': 'InternalError',\n};\n\nexport class SuiHTTPTransportError extends Error {}\n\nexport class JsonRpcError extends SuiHTTPTransportError {\n\tcode: number;\n\ttype: string;\n\n\tconstructor(message: string, code: number) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.type = CODE_TO_ERROR_TYPE[code] ?? 'ServerError';\n\t}\n}\n\nexport class SuiHTTPStatusError extends SuiHTTPTransportError {\n\tstatus: number;\n\tstatusText: string;\n\n\tconstructor(message: string, status: number, statusText: string) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.statusText = statusText;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JsonRpcError } from './errors.js';\n\nfunction getWebsocketUrl(httpUrl: string): string {\n\tconst url = new URL(httpUrl);\n\turl.protocol = url.protocol.replace('http', 'ws');\n\treturn url.toString();\n}\n\ntype JsonRpcMessage =\n\t| {\n\t\t\tid: number;\n\t\t\tresult: never;\n\t\t\terror: {\n\t\t\t\tcode: number;\n\t\t\t\tmessage: string;\n\t\t\t};\n\t  }\n\t| {\n\t\t\tid: number;\n\t\t\tresult: unknown;\n\t\t\terror: never;\n\t  }\n\t| {\n\t\t\tmethod: string;\n\t\t\tparams: NotificationMessageParams;\n\t  };\n\ntype NotificationMessageParams = {\n\tsubscription?: number;\n\tresult: object;\n};\n\ntype SubscriptionRequest<T = any> = {\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: any[];\n\tonMessage: (event: T) => void;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n\t/**\n\t * Custom WebSocket class to use. Defaults to the global WebSocket class, if available.\n\t */\n\tWebSocketConstructor?: typeof WebSocket;\n\t/**\n\t * Milliseconds before timing out while calling an RPC method\n\t */\n\tcallTimeout?: number;\n\t/**\n\t * Milliseconds between attempts to connect\n\t */\n\treconnectTimeout?: number;\n\t/**\n\t * Maximum number of times to try connecting before giving up\n\t */\n\tmaxReconnects?: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS = {\n\t// We fudge the typing because we also check for undefined in the constructor:\n\tWebSocketConstructor: (typeof WebSocket !== 'undefined'\n\t\t? WebSocket\n\t\t: undefined) as typeof WebSocket,\n\tcallTimeout: 30000,\n\treconnectTimeout: 3000,\n\tmaxReconnects: 5,\n} satisfies WebsocketClientOptions;\n\nexport class WebsocketClient {\n\tendpoint: string;\n\toptions: Required<WebsocketClientOptions>;\n\t#requestId = 0;\n\t#disconnects = 0;\n\t#webSocket: WebSocket | null = null;\n\t#connectionPromise: Promise<WebSocket> | null = null;\n\t#subscriptions = new Set<RpcSubscription>();\n\t#pendingRequests = new Map<\n\t\tnumber,\n\t\t{\n\t\t\tresolve: (result: Extract<JsonRpcMessage, { id: number }>) => void;\n\t\t\treject: (reason: unknown) => void;\n\t\t\ttimeout: ReturnType<typeof setTimeout>;\n\t\t}\n\t>();\n\n\tconstructor(endpoint: string, options: WebsocketClientOptions = {}) {\n\t\tthis.endpoint = endpoint;\n\t\tthis.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };\n\n\t\tif (!this.options.WebSocketConstructor) {\n\t\t\tthrow new Error('Missing WebSocket constructor');\n\t\t}\n\n\t\tif (this.endpoint.startsWith('http')) {\n\t\t\tthis.endpoint = getWebsocketUrl(this.endpoint);\n\t\t}\n\t}\n\n\tasync makeRequest<T>(method: string, params: any[]): Promise<T> {\n\t\tconst webSocket = await this.#setupWebSocket();\n\n\t\treturn new Promise<Extract<JsonRpcMessage, { id: number }>>((resolve, reject) => {\n\t\t\tthis.#requestId += 1;\n\t\t\tthis.#pendingRequests.set(this.#requestId, {\n\t\t\t\tresolve: resolve,\n\t\t\t\treject,\n\t\t\t\ttimeout: setTimeout(() => {\n\t\t\t\t\tthis.#pendingRequests.delete(this.#requestId);\n\t\t\t\t\treject(new Error(`Request timeout: ${method}`));\n\t\t\t\t}, this.options.callTimeout),\n\t\t\t});\n\n\t\t\twebSocket.send(JSON.stringify({ jsonrpc: '2.0', id: this.#requestId, method, params }));\n\t\t}).then(({ error, result }) => {\n\t\t\tif (error) {\n\t\t\t\tthrow new JsonRpcError(error.message, error.code);\n\t\t\t}\n\n\t\t\treturn result as T;\n\t\t});\n\t}\n\n\t#setupWebSocket() {\n\t\tif (this.#connectionPromise) {\n\t\t\treturn this.#connectionPromise;\n\t\t}\n\n\t\tthis.#connectionPromise = new Promise<WebSocket>((resolve) => {\n\t\t\tthis.#webSocket?.close();\n\t\t\tthis.#webSocket = new this.options.WebSocketConstructor(this.endpoint);\n\n\t\t\tthis.#webSocket.addEventListener('open', () => {\n\t\t\t\tthis.#disconnects = 0;\n\t\t\t\tresolve(this.#webSocket!);\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('close', () => {\n\t\t\t\tthis.#disconnects++;\n\t\t\t\tif (this.#disconnects <= this.options.maxReconnects) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tthis.#reconnect();\n\t\t\t\t\t}, this.options.reconnectTimeout);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.#webSocket.addEventListener('message', ({ data }: { data: string }) => {\n\t\t\t\tlet json: JsonRpcMessage;\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(data) as JsonRpcMessage;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ('id' in json && json.id != null && this.#pendingRequests.has(json.id)) {\n\t\t\t\t\tconst { resolve, timeout } = this.#pendingRequests.get(json.id)!;\n\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\tresolve(json);\n\t\t\t\t} else if ('params' in json) {\n\t\t\t\t\tconst { params } = json;\n\t\t\t\t\tthis.#subscriptions.forEach((subscription) => {\n\t\t\t\t\t\tif (subscription.subscriptionId === params.subscription)\n\t\t\t\t\t\t\tif (params.subscription === subscription.subscriptionId) {\n\t\t\t\t\t\t\t\tsubscription.onMessage(params.result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this.#connectionPromise;\n\t}\n\n\tasync #reconnect() {\n\t\tthis.#webSocket?.close();\n\t\tthis.#connectionPromise = null;\n\n\t\treturn Promise.allSettled(\n\t\t\t[...this.#subscriptions].map((subscription) => subscription.subscribe(this)),\n\t\t);\n\t}\n\n\tasync subscribe<T>(input: SubscriptionRequest<T>) {\n\t\tconst subscription = new RpcSubscription(input);\n\t\tthis.#subscriptions.add(subscription);\n\t\tawait subscription.subscribe(this);\n\t\treturn () => subscription.unsubscribe(this);\n\t}\n}\n\nclass RpcSubscription {\n\tsubscriptionId: number | null = null;\n\tinput: SubscriptionRequest<any>;\n\tsubscribed = false;\n\n\tconstructor(input: SubscriptionRequest) {\n\t\tthis.input = input;\n\t}\n\n\tonMessage(message: unknown) {\n\t\tif (this.subscribed) {\n\t\t\tthis.input.onMessage(message);\n\t\t}\n\t}\n\n\tasync unsubscribe(client: WebsocketClient) {\n\t\tconst { subscriptionId } = this;\n\t\tthis.subscribed = false;\n\t\tif (subscriptionId == null) return false;\n\t\tthis.subscriptionId = null;\n\n\t\treturn client.makeRequest(this.input.unsubscribe, [subscriptionId]);\n\t}\n\n\tasync subscribe(client: WebsocketClient) {\n\t\tthis.subscriptionId = null;\n\t\tthis.subscribed = true;\n\t\tconst newSubscriptionId = await client.makeRequest<number>(\n\t\t\tthis.input.method,\n\t\t\tthis.input.params,\n\t\t);\n\n\t\tif (this.subscribed) {\n\t\t\tthis.subscriptionId = newSubscriptionId;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from '../version.js';\nimport { JsonRpcError, SuiHTTPStatusError } from './errors.js';\nimport type { WebsocketClientOptions } from './rpc-websocket-client.js';\nimport { WebsocketClient } from './rpc-websocket-client.js';\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = { [header: string]: string };\n\ninterface SuiHTTPTransportOptions {\n\tfetch?: typeof fetch;\n\tWebSocketConstructor?: typeof WebSocket;\n\turl: string;\n\trpc?: {\n\t\theaders?: HttpHeaders;\n\t\turl?: string;\n\t};\n\twebsocket?: WebsocketClientOptions & {\n\t\turl?: string;\n\t};\n}\n\nexport interface SuiTransportRequestOptions {\n\tmethod: string;\n\tparams: unknown[];\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nexport interface SuiTransportSubscribeOptions<T> {\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: unknown[];\n\tonMessage: (event: T) => void;\n}\n\nexport interface SuiTransport {\n\trequest<T = unknown>(input: SuiTransportRequestOptions): Promise<T>;\n\tsubscribe<T = unknown>(input: SuiTransportSubscribeOptions<T>): Promise<() => Promise<boolean>>;\n}\n\nexport class SuiHTTPTransport implements SuiTransport {\n\t#requestId = 0;\n\t#options: SuiHTTPTransportOptions;\n\t#websocketClient?: WebsocketClient;\n\n\tconstructor(options: SuiHTTPTransportOptions) {\n\t\tthis.#options = options;\n\t}\n\n\tfetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n\t\tconst fetch = this.#options.fetch ?? globalThis.fetch;\n\n\t\tif (!fetch) {\n\t\t\tthrow new Error(\n\t\t\t\t'The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.',\n\t\t\t);\n\t\t}\n\n\t\treturn fetch(input, init);\n\t}\n\n\t#getWebsocketClient(): WebsocketClient {\n\t\tif (!this.#websocketClient) {\n\t\t\tconst WebSocketConstructor = this.#options.WebSocketConstructor ?? globalThis.WebSocket;\n\t\t\tif (!WebSocketConstructor) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.#websocketClient = new WebsocketClient(\n\t\t\t\tthis.#options.websocket?.url ?? this.#options.url,\n\t\t\t\t{\n\t\t\t\t\tWebSocketConstructor,\n\t\t\t\t\t...this.#options.websocket,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\treturn this.#websocketClient;\n\t}\n\n\tasync request<T>(input: SuiTransportRequestOptions): Promise<T> {\n\t\tthis.#requestId += 1;\n\n\t\tconst res = await this.fetch(this.#options.rpc?.url ?? this.#options.url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t'Client-Sdk-Type': 'typescript',\n\t\t\t\t'Client-Sdk-Version': PACKAGE_VERSION,\n\t\t\t\t'Client-Target-Api-Version': TARGETED_RPC_VERSION,\n\t\t\t\t...this.#options.rpc?.headers,\n\t\t\t},\n\t\t\tbody: JSON.stringify({\n\t\t\t\tjsonrpc: '2.0',\n\t\t\t\tid: this.#requestId,\n\t\t\t\tmethod: input.method,\n\t\t\t\tparams: input.params,\n\t\t\t}),\n\t\t});\n\n\t\tif (!res.ok) {\n\t\t\tthrow new SuiHTTPStatusError(\n\t\t\t\t`Unexpected status code: ${res.status}`,\n\t\t\t\tres.status,\n\t\t\t\tres.statusText,\n\t\t\t);\n\t\t}\n\n\t\tconst data = await res.json();\n\n\t\tif ('error' in data && data.error != null) {\n\t\t\tthrow new JsonRpcError(data.error.message, data.error.code);\n\t\t}\n\n\t\treturn data.result;\n\t}\n\n\tasync subscribe<T>(input: SuiTransportSubscribeOptions<T>): Promise<() => Promise<boolean>> {\n\t\tconst unsubscribe = await this.#getWebsocketClient().subscribe(input);\n\n\t\treturn async () => !!(await unsubscribe());\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getFullnodeUrl(network: 'mainnet' | 'testnet' | 'devnet' | 'localnet') {\n\tswitch (network) {\n\t\tcase 'mainnet':\n\t\t\treturn 'https://fullnode.mainnet.sui.io:443';\n\t\tcase 'testnet':\n\t\t\treturn 'https://fullnode.testnet.sui.io:443';\n\t\tcase 'devnet':\n\t\t\treturn 'https://fullnode.devnet.sui.io:443';\n\t\tcase 'localnet':\n\t\t\treturn 'http://127.0.0.1:9000';\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown network: ${network}`);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TypeTag } from './index.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromB64,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoB64,\n\ttoHEX,\n} from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../transactions/Transactions.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\nexport type SuiObjectRef = {\n\t/** Base64 string representing the object digest */\n\tobjectId: string;\n\t/** Object version */\n\tversion: number | string | bigint;\n\t/** Hex code as string representing the object id */\n\tdigest: string;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRef }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRef };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRef[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\nconst IntentScope = bcs.enum('IntentScope', {\n\tTransactionData: null,\n\tTransactionEffects: null,\n\tCheckpointSummary: null,\n\tPersonalMessage: null,\n});\n\nconst IntentVersion = bcs.enum('IntentVersion', {\n\tV0: null,\n});\n\nconst AppId = bcs.enum('AppId', {\n\tSui: null,\n});\n\nconst Intent = bcs.struct('Intent', {\n\tscope: IntentScope,\n\tversion: IntentVersion,\n\tappId: AppId,\n});\n\nconst IntentMessage = bcs.generic(['T'], (T) =>\n\tbcs.struct('IntentMessage<T>', {\n\t\tintent: Intent,\n\t\tvalue: T,\n\t}),\n);\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst base64String = bcs.vector(bcs.u8()).transform({\n\tinput: (val: string | Uint8Array) => (typeof val === 'string' ? fromB64(val) : val),\n\toutput: (val) => toB64(new Uint8Array(val)),\n});\n\nconst SenderSignedTransaction = bcs.struct('SenderSignedTransaction', {\n\tintentMessage: IntentMessage(TransactionData),\n\ttxSignatures: bcs.vector(base64String),\n});\n\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n\tname: 'SenderSignedData',\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSenderSignedTransaction,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport { array, bigint, boolean, integer, number, object, string, union } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SharedObjectRef } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\n\nexport const SuiObjectRef = object({\n\t/** Base64 string representing the object digest */\n\tdigest: string(),\n\t/** Hex code as string representing the object id */\n\tobjectId: string(),\n\t/** Object version */\n\tversion: union([number(), string(), bigint()]),\n});\nexport type SuiObjectRef = Infer<typeof SuiObjectRef>;\n\nconst ObjectArg = union([\n\tobject({ ImmOrOwned: SuiObjectRef }),\n\tobject({\n\t\tShared: object({\n\t\t\tobjectId: string(),\n\t\t\tinitialSharedVersion: union([integer(), string()]),\n\t\t\tmutable: boolean(),\n\t\t}),\n\t}),\n\tobject({ Receiving: SuiObjectRef }),\n]);\n\nexport const PureCallArg = object({ Pure: array(integer()) });\nexport const ObjectCallArg = object({ Object: ObjectArg });\nexport type PureCallArg = Infer<typeof PureCallArg>;\nexport type ObjectCallArg = Infer<typeof ObjectCallArg>;\n\nexport const BuilderCallArg = union([PureCallArg, ObjectCallArg]);\nexport type BuilderCallArg = Infer<typeof BuilderCallArg>;\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>, type?: string): PureCallArg;\n/** @deprecated pass SerializedBcs values instead */\nfunction Pure(data: unknown, type?: string): PureCallArg;\nfunction Pure(data: unknown, type?: string): PureCallArg {\n\treturn {\n\t\tPure: Array.from(\n\t\t\tdata instanceof Uint8Array\n\t\t\t\t? data\n\t\t\t\t: isSerializedBcs(data)\n\t\t\t\t? data.toBytes()\n\t\t\t\t: // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:\n\t\t\t\t  bcs.ser(type!, data, { maxSize: Infinity }).toBytes(),\n\t\t),\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tImmOrOwned: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({ objectId, mutable, initialSharedVersion }: SharedObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tShared: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n\t\treturn {\n\t\t\tObject: {\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n\nexport function getIdFromCallArg(arg: string | ObjectCallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\tif ('ImmOrOwned' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);\n\t}\n\n\tif ('Receiving' in arg.Object) {\n\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t}\n\n\treturn normalizeSuiAddress(arg.Object.Shared.objectId);\n}\n\nexport function getSharedObjectInput(arg: BuilderCallArg): SharedObjectRef | undefined {\n\treturn typeof arg === 'object' && 'Object' in arg && 'Shared' in arg.Object\n\t\t? arg.Object.Shared\n\t\t: undefined;\n}\n\nexport function isSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn !!getSharedObjectInput(arg);\n}\n\nexport function isMutableSharedObjectInput(arg: BuilderCallArg): boolean {\n\treturn getSharedObjectInput(arg)?.mutable ?? false;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { TransactionBlockInput } from './Transactions.js';\n\nexport function createPure(\n\tmakePure: (value: unknown, type?: string | undefined) => TransactionBlockInput,\n) {\n\t/**\n\t * Add a new non-object input to the transaction.\n\t */\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): TransactionBlockInput;\n\t/**\n\t * @deprecated Pass the pure value as SerializedBcs instead.\n\t */\n\tfunction pure(\n\t\t/**\n\t\t * The pure value that will be used as the input value. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: unknown,\n\t\t/**\n\t\t * The BCS type to serialize the value into. If not provided, the type will automatically be determined\n\t\t * based on how the input is used.\n\t\t */\n\t\ttype?: string,\n\t): TransactionBlockInput;\n\n\tfunction pure(value: unknown, type?: string): TransactionBlockInput {\n\t\treturn makePure(value, type);\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Struct } from 'superstruct';\nimport { create as superstructCreate } from 'superstruct';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\n\nexport function create<T, S>(value: T, struct: Struct<T, S>): T {\n\treturn superstructCreate(value, struct);\n}\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiJsonValue, SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { isValidSuiAddress } from '../utils/sui-types.js';\nimport { extractStructTag } from './utils.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nconst RESOLVED_SUI_ID = {\n\taddress: SUI_FRAMEWORK_ADDRESS,\n\tmodule: OBJECT_MODULE_NAME,\n\tname: ID_STRUCT_NAME,\n};\nconst RESOLVED_ASCII_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_ASCII_MODULE_NAME,\n\tname: STD_ASCII_STRUCT_NAME,\n};\nconst RESOLVED_UTF8_STR = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_UTF8_MODULE_NAME,\n\tname: STD_UTF8_STRUCT_NAME,\n};\n\nconst RESOLVED_STD_OPTION = {\n\taddress: MOVE_STDLIB_ADDRESS,\n\tmodule: STD_OPTION_MODULE_NAME,\n\tname: STD_OPTION_STRUCT_NAME,\n};\n\nconst isSameStruct = (a: any, b: any) =>\n\ta.address === b.address && a.module === b.module && a.name === b.name;\n\nexport function isTxContext(param: SuiMoveNormalizedType): boolean {\n\tconst struct = extractStructTag(param)?.Struct;\n\treturn (\n\t\tstruct?.address === '0x2' && struct?.module === 'tx_context' && struct?.name === 'TxContext'\n\t);\n}\n\nfunction expectType(typeName: string, argVal?: SuiJsonValue) {\n\tif (typeof argVal === 'undefined') {\n\t\treturn;\n\t}\n\tif (typeof argVal !== typeName) {\n\t\tthrow new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n\t}\n}\n\nconst allowedTypes = ['Address', 'Bool', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256'];\n\nexport function getPureSerializationType(\n\tnormalizedType: SuiMoveNormalizedType,\n\targVal: SuiJsonValue | undefined,\n): string | undefined {\n\tif (typeof normalizedType === 'string' && allowedTypes.includes(normalizedType)) {\n\t\tif (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {\n\t\t\texpectType('number', argVal);\n\t\t} else if (normalizedType === 'Bool') {\n\t\t\texpectType('boolean', argVal);\n\t\t} else if (normalizedType === 'Address') {\n\t\t\texpectType('string', argVal);\n\t\t\tif (argVal && !isValidSuiAddress(argVal as string)) {\n\t\t\t\tthrow new Error('Invalid Sui Address');\n\t\t\t}\n\t\t}\n\t\treturn normalizedType.toLowerCase();\n\t} else if (typeof normalizedType === 'string') {\n\t\tthrow new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n\t}\n\n\tif ('Vector' in normalizedType) {\n\t\tif ((argVal === undefined || typeof argVal === 'string') && normalizedType.Vector === 'U8') {\n\t\t\treturn 'string';\n\t\t}\n\n\t\tif (argVal !== undefined && !Array.isArray(argVal)) {\n\t\t\tthrow new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n\t\t}\n\n\t\tconst innerType = getPureSerializationType(\n\t\t\tnormalizedType.Vector,\n\t\t\t// undefined when argVal is empty\n\t\t\targVal ? argVal[0] : undefined,\n\t\t);\n\n\t\tif (innerType === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn `vector<${innerType}>`;\n\t}\n\n\tif ('Struct' in normalizedType) {\n\t\tif (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n\t\t\treturn 'string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n\t\t\treturn 'utf8string';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n\t\t\treturn 'address';\n\t\t} else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n\t\t\tconst optionToVec: SuiMoveNormalizedType = {\n\t\t\t\tVector: normalizedType.Struct.typeArguments[0],\n\t\t\t};\n\t\t\treturn getPureSerializationType(optionToVec, argVal);\n\t\t}\n\t}\n\n\treturn undefined;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n\tany,\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tobject,\n\toptional,\n\trecord,\n\tstring,\n\tunion,\n\tunknown,\n} from 'superstruct';\n\nimport type { TypeTag } from '../bcs/index.js';\nimport { bcs } from '../bcs/index.js';\nimport { TypeTagSerializer } from '../bcs/type-tag-serializer.js';\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport { Inputs } from './Inputs.js';\nimport { create } from './utils.js';\n\nconst option = <T extends Struct<any, any>>(some: T) =>\n\tunion([object({ None: union([literal(true), literal(null)]) }), object({ Some: some })]);\n\nexport const TransactionBlockInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: integer(),\n\t\tvalue: optional(any()),\n\t\ttype: literal('pure'),\n\t}),\n]);\nexport type TransactionBlockInput = Infer<typeof TransactionBlockInput>;\n\nconst TransactionArgumentTypes = [\n\tTransactionBlockInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: integer() }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: integer(),\n\t\tresultIndex: integer(),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\nexport type TransactionArgument = Infer<typeof TransactionArgument>;\n\nexport const MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: define<`${string}::${string}::${string}`>('target', string().validator),\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\nexport type MoveCallTransaction = Infer<typeof MoveCallTransaction>;\n\nexport const TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\nexport type TransferObjectsTransaction = Infer<typeof TransferObjectsTransaction>;\n\nexport const SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\nexport type SplitCoinsTransaction = Infer<typeof SplitCoinsTransaction>;\n\nexport const MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\nexport type MergeCoinsTransaction = Infer<typeof MergeCoinsTransaction>;\n\nexport const MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\t// TODO: ideally we should use `TypeTag` instead of `record()` here,\n\t// but TypeTag is recursively defined and it's tricky to define a\n\t// recursive struct in superstruct\n\ttype: optional(option(record(string(), unknown()))) as never as Struct<\n\t\t{ Some: TypeTag } | { None: true | null }\n\t>,\n\tobjects: array(TransactionArgument),\n});\nexport type MakeMoveVecTransaction = Infer<typeof MakeMoveVecTransaction>;\n\nexport const PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n});\nexport type PublishTransaction = Infer<typeof PublishTransaction>;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\nexport const UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(integer())),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\nexport type UpgradeTransaction = Infer<typeof UpgradeTransaction>;\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nexport const TransactionType = union([...TransactionTypes]);\nexport type TransactionType = Infer<typeof TransactionType>;\n\nexport function getTransactionType(data: unknown) {\n\tassert(data, TransactionType);\n\treturn TransactionTypes.find((schema) => is(data, schema as Struct))!;\n}\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Transactions = {\n\tMoveCall(\n\t\tinput: Omit<MoveCallTransaction, 'kind' | 'arguments' | 'typeArguments'> & {\n\t\t\targuments?: TransactionArgument[];\n\t\t\ttypeArguments?: string[];\n\t\t},\n\t): MoveCallTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MoveCall',\n\t\t\t\ttarget: input.target,\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t},\n\t\t\tMoveCallTransaction,\n\t\t);\n\t},\n\tTransferObjects(\n\t\tobjects: TransactionArgument[],\n\t\taddress: TransactionArgument,\n\t): TransferObjectsTransaction {\n\t\tif (address.kind === 'Input' && address.type === 'pure' && typeof address.value !== 'object') {\n\t\t\taddress.value = Inputs.Pure(bcs.Address.serialize(address.value));\n\t\t}\n\n\t\treturn create({ kind: 'TransferObjects', objects, address }, TransferObjectsTransaction);\n\t},\n\tSplitCoins(coin: TransactionArgument, amounts: TransactionArgument[]): SplitCoinsTransaction {\n\t\t// Handle deprecated usage of `Input.Pure(100)`\n\t\tamounts.forEach((input) => {\n\t\t\tif (input.kind === 'Input' && input.type === 'pure' && typeof input.value !== 'object') {\n\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t}\n\t\t});\n\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'SplitCoins',\n\t\t\t\tcoin,\n\t\t\t\tamounts,\n\t\t\t},\n\t\t\tSplitCoinsTransaction,\n\t\t);\n\t},\n\tMergeCoins(\n\t\tdestination: TransactionArgument,\n\t\tsources: TransactionArgument[],\n\t): MergeCoinsTransaction {\n\t\treturn create({ kind: 'MergeCoins', destination, sources }, MergeCoinsTransaction);\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): PublishTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Publish',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t\tPublishTransaction,\n\t\t);\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionArgument;\n\t}): UpgradeTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'Upgrade',\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? Array.from(fromB64(module)) : module,\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackageId,\n\t\t\t\tticket,\n\t\t\t},\n\t\t\tUpgradeTransaction,\n\t\t);\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: Omit<MakeMoveVecTransaction, 'kind' | 'type'> & {\n\t\ttype?: string;\n\t}): MakeMoveVecTransaction {\n\t\treturn create(\n\t\t\t{\n\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\ttype: type ? { Some: TypeTagSerializer.parseFromStr(type) } : { None: null },\n\t\t\t\tobjects,\n\t\t\t},\n\t\t\tMakeMoveVecTransaction,\n\t\t);\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport {\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tnullable,\n\tobject,\n\toptional,\n\tstring,\n\tunion,\n} from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { hashTypedData } from './hash.js';\nimport { BuilderCallArg, PureCallArg, SuiObjectRef } from './Inputs.js';\nimport { TransactionBlockInput, TransactionType } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport const TransactionExpiration = optional(\n\tnullable(\n\t\tunion([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })]),\n\t),\n);\nexport type TransactionExpiration = Infer<typeof TransactionExpiration>;\n\nconst StringEncodedBigint = define<string | number | bigint>('StringEncodedBigint', (val) => {\n\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\ttry {\n\t\tBigInt(val as string);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(SuiObjectRef)),\n\towner: optional(string()),\n});\ntype GasConfig = Infer<typeof GasConfig>;\n\nexport const SerializedTransactionDataBuilder = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: TransactionExpiration,\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionBlockInput),\n\ttransactions: array(TransactionType),\n});\nexport type SerializedTransactionDataBuilder = Infer<typeof SerializedTransactionDataBuilder>;\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionBlockDataBuilder {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\t\tconst programmableTx = 'ProgrammableTransaction' in kind ? kind.ProgrammableTransaction : null;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tgasConfig: {},\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx =\n\t\t\t'ProgrammableTransaction' in data.kind ? data?.kind?.ProgrammableTransaction : null;\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tsender: data.sender,\n\t\t\t\texpiration: data.expiration,\n\t\t\t\tgasConfig: data.gasData,\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic restore(data: SerializedTransactionDataBuilder) {\n\t\tassert(data, SerializedTransactionDataBuilder);\n\t\tconst transactionData = new TransactionBlockDataBuilder();\n\t\tObject.assign(transactionData, data);\n\t\treturn transactionData;\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toB58(hash);\n\t}\n\n\tversion = 1 as const;\n\tsender?: string;\n\texpiration?: TransactionExpiration;\n\tgasConfig: GasConfig;\n\tinputs: TransactionBlockInput[];\n\ttransactions: TransactionType[];\n\n\tconstructor(clone?: SerializedTransactionDataBuilder) {\n\t\tthis.sender = clone?.sender;\n\t\tthis.expiration = clone?.expiration;\n\t\tthis.gasConfig = clone?.gasConfig ?? {};\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.transactions = clone?.transactions ?? [];\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: Pick<Partial<TransactionBlockDataBuilder>, 'sender' | 'gasConfig' | 'expiration'>;\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// Resolve inputs down to values:\n\t\tconst inputs = this.inputs.map((input) => {\n\t\t\tassert(input.value, BuilderCallArg);\n\t\t\treturn input.value;\n\t\t});\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\ttransactions: this.transactions,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasConfig = { ...this.gasConfig, ...overrides?.gasConfig };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasConfig.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasConfig.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasConfig.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasConfig.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n\t\t\t\tprice: BigInt(gasConfig.price),\n\t\t\t\tbudget: BigInt(gasConfig.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\ttransactions: this.transactions,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): SerializedTransactionDataBuilder {\n\t\treturn create(this, SerializedTransactionDataBuilder);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tObjectCallArg,\n\tPureCallArg,\n\tSuiObjectRef,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create, extractMutableReference, extractReference, extractStructTag } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Signer;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\n\t\t// Upgrade shared object inputs to mutable if needed:\n\t\tif (\n\t\t\tinserted &&\n\t\t\tis(inserted.value, ObjectCallArg) &&\n\t\t\t'Shared' in inserted.value.Object &&\n\t\t\tis(value, ObjectCallArg) &&\n\t\t\t'Shared' in value.Object\n\t\t) {\n\t\t\tinserted.value.Object.Shared.mutable =\n\t\t\t\tinserted.value.Object.Shared.mutable || value.Object.Shared.mutable;\n\t\t}\n\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(object.data!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(object.data!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { fromB58, toB64, toHEX } from '@mysten/bcs';\n\nimport type { Signer } from '../cryptography/index.js';\nimport type { TransactionBlock } from '../transactions/index.js';\nimport { isTransactionBlock } from '../transactions/index.js';\nimport {\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tisValidTransactionDigest,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n} from '../utils/sui-types.js';\nimport { normalizeSuiNSName } from '../utils/suins.js';\nimport { SuiHTTPTransport } from './http-transport.js';\nimport type { SuiTransport } from './http-transport.js';\nimport type {\n\tAddressMetrics,\n\tAllEpochsAddressMetrics,\n\tCheckpoint,\n\tCheckpointPage,\n\tCoinBalance,\n\tCoinMetadata,\n\tCoinSupply,\n\tCommitteeInfo,\n\tDelegatedStake,\n\tDevInspectResults,\n\tDevInspectTransactionBlockParams,\n\tDryRunTransactionBlockParams,\n\tDryRunTransactionBlockResponse,\n\tDynamicFieldPage,\n\tEpochInfo,\n\tEpochMetricsPage,\n\tEpochPage,\n\tExecuteTransactionBlockParams,\n\tGetAllBalancesParams,\n\tGetAllCoinsParams,\n\tGetBalanceParams,\n\tGetCheckpointParams,\n\tGetCheckpointsParams,\n\tGetCoinMetadataParams,\n\tGetCoinsParams,\n\tGetCommitteeInfoParams,\n\tGetDynamicFieldObjectParams,\n\tGetDynamicFieldsParams,\n\tGetMoveFunctionArgTypesParams,\n\tGetNormalizedMoveFunctionParams,\n\tGetNormalizedMoveModuleParams,\n\tGetNormalizedMoveModulesByPackageParams,\n\tGetNormalizedMoveStructParams,\n\tGetObjectParams,\n\tGetOwnedObjectsParams,\n\tGetProtocolConfigParams,\n\tGetStakesByIdsParams,\n\tGetStakesParams,\n\tGetTotalSupplyParams,\n\tGetTransactionBlockParams,\n\tMoveCallMetrics,\n\tMultiGetObjectsParams,\n\tMultiGetTransactionBlocksParams,\n\tNetworkMetrics,\n\tObjectRead,\n\tOrder,\n\tPaginatedCoins,\n\tPaginatedEvents,\n\tPaginatedObjectsResponse,\n\tPaginatedTransactionResponse,\n\tProtocolConfig,\n\tQueryEventsParams,\n\tQueryTransactionBlocksParams,\n\tResolvedNameServiceNames,\n\tResolveNameServiceAddressParams,\n\tResolveNameServiceNamesParams,\n\tSubscribeEventParams,\n\tSubscribeTransactionParams,\n\tSuiEvent,\n\tSuiMoveFunctionArgType,\n\tSuiMoveNormalizedFunction,\n\tSuiMoveNormalizedModule,\n\tSuiMoveNormalizedModules,\n\tSuiMoveNormalizedStruct,\n\tSuiObjectResponse,\n\tSuiObjectResponseQuery,\n\tSuiSystemStateSummary,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseQuery,\n\tTransactionEffects,\n\tTryGetPastObjectParams,\n\tUnsubscribe,\n\tValidatorsApy,\n} from './types/index.js';\n\nexport interface PaginationArguments<Cursor> {\n\t/** Optional paging cursor */\n\tcursor?: Cursor;\n\t/** Maximum item returned per page */\n\tlimit?: number | null;\n}\n\nexport interface OrderArguments {\n\torder?: Order | null;\n}\n\n/**\n * Configuration options for the SuiClient\n * You must provide either a `url` or a `transport`\n */\nexport type SuiClientOptions = NetworkOrTransport;\n\nexport type NetworkOrTransport =\n\t| {\n\t\t\turl: string;\n\t\t\ttransport?: never;\n\t  }\n\t| {\n\t\t\ttransport: SuiTransport;\n\t\t\turl?: never;\n\t  };\n\nexport const SUI_CLIENT_BRAND = Symbol.for('@mysten/SuiClient');\n\nexport function isSuiClient(client: unknown): client is SuiClient {\n\treturn (\n\t\ttypeof client === 'object' &&\n\t\tclient !== null &&\n\t\t(client as { [SUI_CLIENT_BRAND]: unknown })[SUI_CLIENT_BRAND] === true\n\t);\n}\n\nexport class SuiClient {\n\tprotected transport: SuiTransport;\n\n\tget [SUI_CLIENT_BRAND]() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Establish a connection to a Sui RPC endpoint\n\t *\n\t * @param options configuration options for the API Client\n\t */\n\tconstructor(options: SuiClientOptions) {\n\t\tthis.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });\n\t}\n\n\tasync getRpcApiVersion(): Promise<string | undefined> {\n\t\tconst resp = await this.transport.request<{ info: { version: string } }>({\n\t\t\tmethod: 'rpc.discover',\n\t\t\tparams: [],\n\t\t});\n\n\t\treturn resp.info.version;\n\t}\n\n\t/**\n\t * Get all Coin<`coin_type`> objects owned by an address.\n\t */\n\tasync getCoins(input: GetCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCoins',\n\t\t\tparams: [input.owner, input.coinType, input.cursor, input.limit],\n\t\t});\n\t}\n\n\t/**\n\t * Get all Coin objects owned by an address.\n\t */\n\tasync getAllCoins(input: GetAllCoinsParams): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllCoins',\n\t\t\tparams: [input.owner, input.cursor, input.limit],\n\t\t});\n\t}\n\n\t/**\n\t * Get the total coin balance for one coin type, owned by the address owner.\n\t */\n\tasync getBalance(input: GetBalanceParams): Promise<CoinBalance> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getBalance',\n\t\t\tparams: [input.owner, input.coinType],\n\t\t});\n\t}\n\n\t/**\n\t * Get the total coin balance for all coin types, owned by the address owner.\n\t */\n\tasync getAllBalances(input: GetAllBalancesParams): Promise<CoinBalance[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({ method: 'suix_getAllBalances', params: [input.owner] });\n\t}\n\n\t/**\n\t * Fetch CoinMetadata for a given coin type\n\t */\n\tasync getCoinMetadata(input: GetCoinMetadataParams): Promise<CoinMetadata | null> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCoinMetadata',\n\t\t\tparams: [input.coinType],\n\t\t});\n\t}\n\n\t/**\n\t *  Fetch total supply for a coin\n\t */\n\tasync getTotalSupply(input: GetTotalSupplyParams): Promise<CoinSupply> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getTotalSupply',\n\t\t\tparams: [input.coinType],\n\t\t});\n\t}\n\n\t/**\n\t * Invoke any RPC method\n\t * @param method the method to be invoked\n\t * @param args the arguments to be passed to the RPC request\n\t */\n\tasync call<T = unknown>(method: string, params: unknown[]): Promise<T> {\n\t\treturn await this.transport.request({ method, params });\n\t}\n\n\t/**\n\t * Get Move function argument types like read, write and full access\n\t */\n\tasync getMoveFunctionArgTypes(\n\t\tinput: GetMoveFunctionArgTypesParams,\n\t): Promise<SuiMoveFunctionArgType[]> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getMoveFunctionArgTypes',\n\t\t\tparams: [input.package, input.module, input.function],\n\t\t});\n\t}\n\n\t/**\n\t * Get a map from module name to\n\t * structured representations of Move modules\n\t */\n\tasync getNormalizedMoveModulesByPackage(\n\t\tinput: GetNormalizedMoveModulesByPackageParams,\n\t): Promise<SuiMoveNormalizedModules> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModulesByPackage',\n\t\t\tparams: [input.package],\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move module\n\t */\n\tasync getNormalizedMoveModule(\n\t\tinput: GetNormalizedMoveModuleParams,\n\t): Promise<SuiMoveNormalizedModule> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveModule',\n\t\t\tparams: [input.package, input.module],\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move function\n\t */\n\tasync getNormalizedMoveFunction(\n\t\tinput: GetNormalizedMoveFunctionParams,\n\t): Promise<SuiMoveNormalizedFunction> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveFunction',\n\t\t\tparams: [input.package, input.module, input.function],\n\t\t});\n\t}\n\n\t/**\n\t * Get a structured representation of Move struct\n\t */\n\tasync getNormalizedMoveStruct(\n\t\tinput: GetNormalizedMoveStructParams,\n\t): Promise<SuiMoveNormalizedStruct> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getNormalizedMoveStruct',\n\t\t\tparams: [input.package, input.module, input.struct],\n\t\t});\n\t}\n\n\t/**\n\t * Get all objects owned by an address\n\t */\n\tasync getOwnedObjects(input: GetOwnedObjectsParams): Promise<PaginatedObjectsResponse> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getOwnedObjects',\n\t\t\tparams: [\n\t\t\t\tinput.owner,\n\t\t\t\t{\n\t\t\t\t\tfilter: input.filter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiObjectResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Get details about an object\n\t */\n\tasync getObject(input: GetObjectParams): Promise<SuiObjectResponse> {\n\t\tif (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getObject',\n\t\t\tparams: [input.id, input.options],\n\t\t});\n\t}\n\n\tasync tryGetPastObject(input: TryGetPastObjectParams): Promise<ObjectRead> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_tryGetPastObject',\n\t\t\tparams: [input.id, input.version, input.options],\n\t\t});\n\t}\n\n\t/**\n\t * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n\t */\n\tasync multiGetObjects(input: MultiGetObjectsParams): Promise<SuiObjectResponse[]> {\n\t\tinput.ids.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Object id ${id}`);\n\t\t\t}\n\t\t});\n\t\tconst hasDuplicates = input.ids.length !== new Set(input.ids).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate object ids in batch call ${input.ids}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetObjects',\n\t\t\tparams: [input.ids, input.options],\n\t\t});\n\t}\n\n\t/**\n\t * Get transaction blocks for a given query criteria\n\t */\n\tasync queryTransactionBlocks(\n\t\tinput: QueryTransactionBlocksParams,\n\t): Promise<PaginatedTransactionResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryTransactionBlocks',\n\t\t\tparams: [\n\t\t\t\t{\n\t\t\t\t\tfilter: input.filter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiTransactionBlockResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t\t(input.order || 'descending') === 'descending',\n\t\t\t],\n\t\t});\n\t}\n\n\tasync getTransactionBlock(\n\t\tinput: GetTransactionBlockParams,\n\t): Promise<SuiTransactionBlockResponse> {\n\t\tif (!isValidTransactionDigest(input.digest)) {\n\t\t\tthrow new Error('Invalid Transaction digest');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getTransactionBlock',\n\t\t\tparams: [input.digest, input.options],\n\t\t});\n\t}\n\n\tasync multiGetTransactionBlocks(\n\t\tinput: MultiGetTransactionBlocksParams,\n\t): Promise<SuiTransactionBlockResponse[]> {\n\t\tinput.digests.forEach((d) => {\n\t\t\tif (!isValidTransactionDigest(d)) {\n\t\t\t\tthrow new Error(`Invalid Transaction digest ${d}`);\n\t\t\t}\n\t\t});\n\n\t\tconst hasDuplicates = input.digests.length !== new Set(input.digests).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate digests in batch call ${input.digests}`);\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_multiGetTransactionBlocks',\n\t\t\tparams: [input.digests, input.options],\n\t\t});\n\t}\n\n\tasync executeTransactionBlock(\n\t\tinput: ExecuteTransactionBlockParams,\n\t): Promise<SuiTransactionBlockResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_executeTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toB64(input.transactionBlock),\n\t\t\t\tArray.isArray(input.signature) ? input.signature : [input.signature],\n\t\t\t\tinput.options,\n\t\t\t\tinput.requestType,\n\t\t\t],\n\t\t});\n\t}\n\n\tasync signAndExecuteTransactionBlock({\n\t\ttransactionBlock,\n\t\tsigner,\n\t\t...input\n\t}: {\n\t\ttransactionBlock: Uint8Array | TransactionBlock;\n\t\tsigner: Signer;\n\t} & Omit<\n\t\tExecuteTransactionBlockParams,\n\t\t'transactionBlock' | 'signature'\n\t>): Promise<SuiTransactionBlockResponse> {\n\t\tlet transactionBytes;\n\n\t\tif (transactionBlock instanceof Uint8Array) {\n\t\t\ttransactionBytes = transactionBlock;\n\t\t} else {\n\t\t\ttransactionBlock.setSenderIfNotSet(signer.toSuiAddress());\n\t\t\ttransactionBytes = await transactionBlock.build({ client: this });\n\t\t}\n\n\t\tconst { signature, bytes } = await signer.signTransactionBlock(transactionBytes);\n\n\t\treturn this.executeTransactionBlock({\n\t\t\ttransactionBlock: bytes,\n\t\t\tsignature,\n\t\t\t...input,\n\t\t});\n\t}\n\n\t/**\n\t * Get total number of transactions\n\t */\n\n\tasync getTotalTransactionBlocks(): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'sui_getTotalTransactionBlocks',\n\t\t\tparams: [],\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Getting the reference gas price for the network\n\t */\n\tasync getReferenceGasPrice(): Promise<bigint> {\n\t\tconst resp = await this.transport.request<string>({\n\t\t\tmethod: 'suix_getReferenceGasPrice',\n\t\t\tparams: [],\n\t\t});\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Return the delegated stakes for an address\n\t */\n\tasync getStakes(input: GetStakesParams): Promise<DelegatedStake[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.transport.request({ method: 'suix_getStakes', params: [input.owner] });\n\t}\n\n\t/**\n\t * Return the delegated stakes queried by id.\n\t */\n\tasync getStakesByIds(input: GetStakesByIdsParams): Promise<DelegatedStake[]> {\n\t\tinput.stakedSuiIds.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Stake id ${id}`);\n\t\t\t}\n\t\t});\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getStakesByIds',\n\t\t\tparams: [input.stakedSuiIds],\n\t\t});\n\t}\n\n\t/**\n\t * Return the latest system state content.\n\t */\n\tasync getLatestSuiSystemState(): Promise<SuiSystemStateSummary> {\n\t\treturn await this.transport.request({ method: 'suix_getLatestSuiSystemState', params: [] });\n\t}\n\n\t/**\n\t * Get events for a given query criteria\n\t */\n\tasync queryEvents(input: QueryEventsParams): Promise<PaginatedEvents> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_queryEvents',\n\t\t\tparams: [\n\t\t\t\tinput.query,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t\t(input.order || 'descending') === 'descending',\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Subscribe to get notifications whenever an event matching the filter occurs\n\t */\n\tasync subscribeEvent(\n\t\tinput: SubscribeEventParams & {\n\t\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\t\tonMessage: (event: SuiEvent) => void;\n\t\t},\n\t): Promise<Unsubscribe> {\n\t\treturn this.transport.subscribe({\n\t\t\tmethod: 'suix_subscribeEvent',\n\t\t\tunsubscribe: 'suix_unsubscribeEvent',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t});\n\t}\n\n\tasync subscribeTransaction(\n\t\tinput: SubscribeTransactionParams & {\n\t\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\t\tonMessage: (event: TransactionEffects) => void;\n\t\t},\n\t): Promise<Unsubscribe> {\n\t\treturn this.transport.subscribe({\n\t\t\tmethod: 'suix_subscribeTransaction',\n\t\t\tunsubscribe: 'suix_unsubscribeTransaction',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t});\n\t}\n\n\t/**\n\t * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(\n\t\tinput: DevInspectTransactionBlockParams,\n\t): Promise<DevInspectResults> {\n\t\tlet devInspectTxBytes;\n\t\tif (isTransactionBlock(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(input.sender);\n\t\t\tdevInspectTxBytes = toB64(\n\t\t\t\tawait input.transactionBlock.build({\n\t\t\t\t\tclient: this,\n\t\t\t\t\tonlyTransactionKind: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdevInspectTxBytes = input.transactionBlock;\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdevInspectTxBytes = toB64(input.transactionBlock);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction block format.');\n\t\t}\n\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_devInspectTransactionBlock',\n\t\t\tparams: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch],\n\t\t});\n\t}\n\n\t/**\n\t * Dry run a transaction block and return the result.\n\t */\n\tasync dryRunTransactionBlock(\n\t\tinput: DryRunTransactionBlockParams,\n\t): Promise<DryRunTransactionBlockResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_dryRunTransactionBlock',\n\t\t\tparams: [\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toB64(input.transactionBlock),\n\t\t\t],\n\t\t});\n\t}\n\n\t/**\n\t * Return the list of dynamic field objects owned by an object\n\t */\n\tasync getDynamicFields(input: GetDynamicFieldsParams): Promise<DynamicFieldPage> {\n\t\tif (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFields',\n\t\t\tparams: [input.parentId, input.cursor, input.limit],\n\t\t});\n\t}\n\n\t/**\n\t * Return the dynamic field object information for a specified object\n\t */\n\tasync getDynamicFieldObject(input: GetDynamicFieldObjectParams): Promise<SuiObjectResponse> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getDynamicFieldObject',\n\t\t\tparams: [input.parentId, input.name],\n\t\t});\n\t}\n\n\t/**\n\t * Get the sequence number of the latest checkpoint that has been executed\n\t */\n\tasync getLatestCheckpointSequenceNumber(): Promise<string> {\n\t\tconst resp = await this.transport.request({\n\t\t\tmethod: 'sui_getLatestCheckpointSequenceNumber',\n\t\t\tparams: [],\n\t\t});\n\t\treturn String(resp);\n\t}\n\n\t/**\n\t * Returns information about a given checkpoint\n\t */\n\tasync getCheckpoint(input: GetCheckpointParams): Promise<Checkpoint> {\n\t\treturn await this.transport.request({ method: 'sui_getCheckpoint', params: [input.id] });\n\t}\n\n\t/**\n\t * Returns historical checkpoints paginated\n\t */\n\tasync getCheckpoints(\n\t\tinput: PaginationArguments<CheckpointPage['nextCursor']> & GetCheckpointsParams,\n\t): Promise<CheckpointPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getCheckpoints',\n\t\t\tparams: [input.cursor, input?.limit, input.descendingOrder],\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCommitteeInfo(input?: GetCommitteeInfoParams): Promise<CommitteeInfo> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getCommitteeInfo',\n\t\t\tparams: [input?.epoch],\n\t\t});\n\t}\n\n\tasync getNetworkMetrics(): Promise<NetworkMetrics> {\n\t\treturn await this.transport.request({ method: 'suix_getNetworkMetrics', params: [] });\n\t}\n\n\tasync getAddressMetrics(): Promise<AddressMetrics> {\n\t\treturn await this.transport.request({ method: 'suix_getLatestAddressMetrics', params: [] });\n\t}\n\n\tasync getEpochMetrics(\n\t\tinput?: { descendingOrder?: boolean } & PaginationArguments<EpochMetricsPage['nextCursor']>,\n\t): Promise<EpochMetricsPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochMetrics',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t});\n\t}\n\n\tasync getAllEpochAddressMetrics(input?: {\n\t\tdescendingOrder?: boolean;\n\t}): Promise<AllEpochsAddressMetrics> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getAllEpochAddressMetrics',\n\t\t\tparams: [input?.descendingOrder],\n\t\t});\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getEpochs(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t} & PaginationArguments<EpochPage['nextCursor']>,\n\t): Promise<EpochPage> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_getEpochs',\n\t\t\tparams: [input?.cursor, input?.limit, input?.descendingOrder],\n\t\t});\n\t}\n\n\t/**\n\t * Returns list of top move calls by usage\n\t */\n\tasync getMoveCallMetrics(): Promise<MoveCallMetrics> {\n\t\treturn await this.transport.request({ method: 'suix_getMoveCallMetrics', params: [] });\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCurrentEpoch(): Promise<EpochInfo> {\n\t\treturn await this.transport.request({ method: 'suix_getCurrentEpoch', params: [] });\n\t}\n\n\t/**\n\t * Return the Validators APYs\n\t */\n\tasync getValidatorsApy(): Promise<ValidatorsApy> {\n\t\treturn await this.transport.request({ method: 'suix_getValidatorsApy', params: [] });\n\t}\n\n\t// TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n\tasync getChainIdentifier(): Promise<string> {\n\t\tconst checkpoint = await this.getCheckpoint({ id: '0' });\n\t\tconst bytes = fromB58(checkpoint.digest);\n\t\treturn toHEX(bytes.slice(0, 4));\n\t}\n\n\tasync resolveNameServiceAddress(input: ResolveNameServiceAddressParams): Promise<string | null> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'suix_resolveNameServiceAddress',\n\t\t\tparams: [input.name],\n\t\t});\n\t}\n\n\tasync resolveNameServiceNames({\n\t\tformat = 'dot',\n\t\t...input\n\t}: ResolveNameServiceNamesParams & {\n\t\tformat?: 'at' | 'dot';\n\t}): Promise<ResolvedNameServiceNames> {\n\t\tconst { nextCursor, hasNextPage, data }: ResolvedNameServiceNames =\n\t\t\tawait this.transport.request({\n\t\t\t\tmethod: 'suix_resolveNameServiceNames',\n\t\t\t\tparams: [input.address, input.cursor, input.limit],\n\t\t\t});\n\n\t\treturn {\n\t\t\thasNextPage,\n\t\t\tnextCursor,\n\t\t\tdata: data.map((name) => normalizeSuiNSName(name, format)),\n\t\t};\n\t}\n\n\tasync getProtocolConfig(input?: GetProtocolConfigParams): Promise<ProtocolConfig> {\n\t\treturn await this.transport.request({\n\t\t\tmethod: 'sui_getProtocolConfig',\n\t\t\tparams: [input?.version],\n\t\t});\n\t}\n\n\t/**\n\t * Wait for a transaction block result to be available over the API.\n\t * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n\t * be available via the API.\n\t * This currently polls the `getTransactionBlock` API to check for the transaction.\n\t */\n\tasync waitForTransactionBlock({\n\t\tsignal,\n\t\ttimeout = 60 * 1000,\n\t\tpollInterval = 2 * 1000,\n\t\t...input\n\t}: {\n\t\t/** An optional abort signal that can be used to cancel */\n\t\tsignal?: AbortSignal;\n\t\t/** The amount of time to wait for a transaction block. Defaults to one minute. */\n\t\ttimeout?: number;\n\t\t/** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n\t\tpollInterval?: number;\n\t} & Parameters<SuiClient['getTransactionBlock']>[0]): Promise<SuiTransactionBlockResponse> {\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\ttimeoutSignal.addEventListener('abort', () => reject(timeoutSignal.reason));\n\t\t});\n\n\t\ttimeoutPromise.catch(() => {\n\t\t\t// Swallow unhandled rejections that might be thrown after early return\n\t\t});\n\n\t\twhile (!timeoutSignal.aborted) {\n\t\t\tsignal?.throwIfAborted();\n\t\t\ttry {\n\t\t\t\treturn await this.getTransactionBlock(input);\n\t\t\t} catch (e) {\n\t\t\t\t// Wait for either the next poll interval, or the timeout.\n\t\t\t\tawait Promise.race([\n\t\t\t\t\tnew Promise((resolve) => setTimeout(resolve, pollInterval)),\n\t\t\t\t\ttimeoutPromise,\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\ttimeoutSignal.throwIfAborted();\n\n\t\t// This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n\t\tthrow new Error('Unexpected error while waiting for transaction block.');\n\t}\n}\n"],
  "mappings": "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",
  "names": ["resolve", "_requestId", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "SuiObjectRef", "ObjectArg", "create", "UpgradePolicy", "create", "TransactionExpiration", "SuiObjectRef", "create", "__privateAdd", "__privateSet", "__privateGet", "SuiObjectRef", "__privateMethod", "__privateGet", "create", "__privateMethod", "chunk", "object"]
}
